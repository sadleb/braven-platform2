# frozen_string_literal: true

# Admin controller to manage the roles that users are assigned through Rolify:
# https://github.com/RolifyCommunity/rolify which in turn are used by Pundit
# to authorize access to resources. We've setup the roles to control access to
# `sections`. Sections can be thought of as the way that a user is enrolled in
# Canvas.
#
# This is only for admins to be able to more easily create test and demo accounts
# in unlaunched courses (aka those that are not live). Certain things that require
# the Salesforce information, like Waivers and Pre-Accelerator survey, won't work
# for these users. You have to go through the real flow and have users connected
# to a Salesforce Program for those features to work.
#
# Notes:
#  - the normal path for UsersRoles management is through Salesforce where
#    folks are provisioned in Canvas when they are sent an account creation link
#    and then later have their enrollments adjusted through a nightly Sync To LMS
#    cronjob. For real users, that's how their enrollment should be managed.
#
#  - The `roles` and `users_roles` tables are polymorphic and generated by Rolify.
#    This is why there is no UsersRoles model.
#
# Final note: we only allow using this on non-launched courses for test users instead
# of being a tool to setup real users for a few reasons:
#   1) not everything will work as described above
#   2) if there is an issue requiring users to be setup or edited on the fly, we should
#      fix the root cause in the real flow to avoid noise and overhead when small things
#      don't match up
#   3) as a general rule, we shouldn't be using launched courses for testing. It messes
#      up our data and reports.
class UsersRolesController < ApplicationController
  include DryCrud::Controllers::Nestable
  layout 'admin'

  nested_resource_of User

  # GET /users/:id/users_roles/new
  def new
    authorize :users_role
  end

  # Create a new Enrollment in Canvas. Mimic what Sync To LMS does to provision
  # users from Salesforce.
  #
  # POST /users/:id/users_roles
  def create
    authorize :users_role

    # Mock the info that would be sent by Salesforce and run the normal Sync To LMS
    # and Account Creation logic with it.
    portal_user = Mocks::CanvasUser.new(@user.canvas_user_id)

    sf_participant = Mocks::SalesforceParticipant.new(
      @user.email,
      params[:role_name].to_sym,
      params[:cohort].strip,
      nil,  # cohort-schedule section, expected to not exist
      SalesforceAPI::ENROLLED,
      @user.first_name,
      @user.last_name,
      @user.salesforce_id,
    )

    sf_program = nil
    if params[:role_name].to_sym == RoleConstants::STUDENT_ENROLLMENT
      sf_program = Mocks::SalesforceProgram.new(params[:fellow_course_id])

    elsif params[:role_name].to_sym == RoleConstants::TA_ENROLLMENT
      sf_program = Mocks::SalesforceProgram.new(
        params[:fellow_course_id],
        params[:leadership_coach_course_id],
      )
    end

    SyncPortalEnrollmentForAccount
      .new(user: @user,
           portal_user: portal_user,
           salesforce_participant: sf_participant,
           salesforce_program: sf_program)
      .run

    redirect_to edit_user_path(@user), notice: "Enrollment was successfully created."
  end

  # Delete an Enrollment from Canvas. Mimic what Sync To LMS does to opt-out
  # or drop users from Salesforce.
  #
  # DELETE /users/:user_id/users_roles/:id
  def destroy
    @role = Role.find(params[:id])
    authorize @role, policy_class: UsersRolePolicy

    portal_user = Mocks::CanvasUser.new(@user.canvas_user_id)
    sf_participant = Mocks::SalesforceParticipant.new(
      @user.email,
      @role.name.to_sym,
      :ignored_section_name,
      nil,
      SalesforceAPI::DROPPED,
      @user.first_name,
      @user.last_name,
      @user.salesforce_id,
    )

    # Hacky. If this is a TaEnrollment, the real code assumes it's a Leadership Coach and
    # tries to drop them from both Canvas courses. We're just implementing the ability to
    # delete a single enrollment through this admin UI so it will unenroll the TA and then
    # try again on the same course. Not worth implementing a UI to require specifying both
    # in order to delete LCs
    canvas_course_id = @role.resource.course.canvas_course_id
    sf_program = Mocks::SalesforceProgram.new(canvas_course_id, canvas_course_id)

    SyncPortalEnrollmentForAccount
      .new(user: @user,
           portal_user: portal_user,
           salesforce_participant: sf_participant,
           salesforce_program: sf_program)
      .run

    redirect_to edit_user_path(@user), notice: "Enrollment was successfully delete."
  end

private

  # The SyncPortalEnrollmentForAccount service uses a subset of fields from the
  # Salesforce and Canvas API objects. It's a little hacky, but we're going to mimic
  # a Sync To LMS by just directly calling the service with mock's for the data as
  # though it came from Salesforce/Canvas.
  class Mocks

    CanvasUser = Struct.new(:id)

    SalesforceParticipant = Struct.new(
      :email,
      :platform_role,
      :cohort,
      :cohort_schedule,
      :status,
      :first_name,
      :last_name,
      :contact_id,
    ) do
      def role
        case platform_role
        when RoleConstants::STUDENT_ENROLLMENT
          SalesforceAPI::FELLOW
        when RoleConstants::TA_ENROLLMENT
          SalesforceAPI::LEADERSHIP_COACH
        else
          raise TypeError, "Unexpected platform_role: #{platform_role.inspect}"
        end
      end
    end

    SalesforceProgram = Struct.new(
      :fellow_course_id,
      :leadership_coach_course_id,
    )
  end

end
